<!DOCTYPE html>
<html>
<head>
    <link rel="shortcut icon" href="https://phaser.io/favicon.ico"/>
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.15.1/dist/phaser-arcade-physics.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@1.0.0/dist/tf.min.js"></script>
</head>
<body>

    <script>
    var NUM_PLAYERS = 5;
    var PIPE_START_X = 850;
    var PLAYER_X = 100;
    var PLAYER_Y = 200;
    var PIPE_SPEED = -100;
    var JUMP_SPEED = -150;
    var playerGrp;
    var pipeGrp;
    var ground;
    var closestPipe = [];
    var gameOver;
    var config = {
        type: Phaser.AUTO,
        width: 800,
        height: 600,
        physics: {
            default: 'arcade',
            arcade: {
                gravity: { y: 300 }
            }
        },
        scene: {
            preload: preload,
            create: create,
            update: update
        }
    };

    var game = new Phaser.Game(config);
    var myPhysics;
    var startText;
    var scoreText;
    var points = 0;
    var diedModels = [];

    tf.setBackend('cpu');

    function preload ()
    {
        this.load.setBaseURL('http://labs.phaser.io');

        this.load.image('sky', 'assets/skies/gradient30.png');
        this.load.image('player', 'assets/sprites/phaser-dude.png');
        this.load.image('ground', 'assets/sprites/stripes800x32-bg.png');
    }

    function makePipe () {
        let rndDw = Math.floor(Math.random() * 500) + 360;
        let pipeys = [rndDw - 700, rndDw];
        let pipes = [];
        for (let yp in pipeys) {
            var pipe = pipeGrp.create(PIPE_START_X, pipeys[yp], 'ground');
            pipe.body.setAllowGravity(false);
            pipe.setVelocityX(PIPE_SPEED);
            pipe.setScale(0.08,9);
            pipe.setCollideWorldBounds(false);
            pipe.update = function() {
                if (PIPE_START_X - this.body.x > 350 && yp == 1 && !this.nextPipe) {
                    this.nextPipe = makePipe();
                }
                if (this.body.x < 0) {
                    closestPipe = this.nextPipe;
                    this.destroy();
                }
            };
            pipes.push(pipe);
        }
        return pipes;
    }

    function makePlayers (newModel) {
        for (let i=0; i<NUM_PLAYERS; i++) {
            var player = playerGrp.create(PLAYER_X, getRandomPlayerY(), 'player');
            player.model = newModel?getModel(player):pickOneModel(player);
            player.setCollideWorldBounds(true);
        }
    }

    function create ()
    {
        this.add.image(400, 300, 'sky');

        playerGrp = this.physics.add.group();
        playerGrp.runChildUpdate = true;
        makePlayers(true);

        pipeGrp = this.physics.add.group();
        pipeGrp.runChildUpdate = true;
        closestPipe = makePipe();

        ground = this.physics.add.staticGroup();
        ground.create(400,600,'ground');

        this.physics.add.overlap(playerGrp, ground, killPlayer, null, this);
        this.physics.add.overlap(playerGrp, pipeGrp, killPlayer, null, this);

        this.input.keyboard.on('keydown',function(event){
            if (myPhysics.world.isPaused) {
                startText.setText('');
                myPhysics.resume();
            } else {
                myPhysics.pause();
            }
        });

        startText = this.add.text(this.game.config.width/2 - 150, this.game.config.height/2, 'Hit any key to start', { fontSize: '24px', fill: '#fff' });

        this.physics.pause();
        myPhysics = this.physics;

    }

    function getRandomPlayerY () {
        return Math.floor(Math.random() * 700) + 35;
    }
    function update () {
    }

    function killPlayer (p,i) {
        diedModels.push(p.model);
        p.destroy();
        if (playerGrp.children.size === 0) {
            /*this.physics.pause();
            gameOver = true;
            startText.setText('.... Game over !!');*/
            nextGeneration();
        }
        /*player.setTint(0xff0000);
        this.physics.pause();
        gameOver = true;
        startText.setText('.... Game over !!');
        points = 0;*/
    }

    function nextGeneration() {
        calculateFitness();
        makePlayers(false);
        diedModels = [];
    }

    function calculateFitness() {
        let sum = 0;
        for (let m of diedModels) {
            sum += m.points;
        }
        for (let m of diedModels) {
            m.fitness = m.points / sum;
        }
    }

    function pickOneModel(player) {
        var index = 0;
        var r = Math.random();
        while (r > 0) {
            r = r - diedModels[index].fitness;
            index++;
        }
        index--;
        let m = diedModels[index];
        m.player = player;
        m.points = 0;
        return m;
    }

    function getModel(player) {

        var model = tf.sequential();
        model.add(tf.layers.dense({
            units: 8,
            inputShape: [5],
            activation: 'sigmoid'
        }));
        model.add(tf.layers.dense({
            units: 2,
            activation: 'softmax'
        }));
        player.update = function() {
            if (myPhysics && !myPhysics.world.isPaused) {
                if (closestPipe[0].body.x < 40 && closestPipe[0].body.x > 30) {
                    this.model.points++;
                }
                this.model.predict();
            }
        };
        return {
            points: 0,
            model: model,
            player: player,
            getCurrentState: function() {
                return [this.player.body.y/config.height,
                        closestPipe[0].body.y/config.height,
                        closestPipe[1].body.y/config.height,
                        closestPipe[0].body.x/config.width,
                        this.player.body.velocity.y/config.height];
            },
            predict: function() {
                tf.tidy(()=>{
                    const inputs = this.getCurrentState();
                    const xs = tf.tensor2d([inputs]);
                    const ys = this.model.predict(xs);
                    const outputs = ys.dataSync();
                    if (outputs[0] > outputs[1]) {
                        this.player.setVelocityY(JUMP_SPEED);
                    }
                });
            }
        };

    }
    </script>

</body>
</html>